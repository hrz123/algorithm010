- 完成了leetcode 300题以上打卡

- [数据结构与算法导图](https://github.com/hrz123/algorithm010/blob/master/Week10/数据结构与算法.png)

## 文档没有脑图的树状结构好记忆

毕业总结如果大而全显然也不合适。尽量把一些思考写下来，以后形成树状的记忆。在看洛谷上题目的时候，才感觉到自己还有很多东西都不会，(在上面还学会了蒟蒻这个词)。

但是查理芒格说过，学习并不是追求更多的知识，而是要寻找更好的决策依据。这个更好的决策依据，就是那些经过广泛验证的原理和规律，称之为思维模型。Google的创始人拉里·佩奇也说过：“让我自由地从物理规则去思考问题，而不是迎合哪些所谓的世俗智慧。”

这其实都提醒了我，也让我不断地告诉我自己，真正重要的事情，永远都是非常简单的。我要做的，就是关注本质，坚持下去。

## 数据结构与算法

1. 一维数据结构

   1. 数组

      int a[105]; // c++定义一个105容量的int数组；

      int a[105] = {5,1,3,2,4}; // 定义并初始化

      1. O(1)的随机访问
      2. O(n)的插入和删除
      3. 可以被缓存加速访问

      - 常见算法：

        - 荷兰国旗算法

        - 擂台法（对于指针，比如选择数组中最小的数，比如堆的维护）

        - 双指针：左右指针、前后指针（滑动窗口）、快慢指针

        - 与单调栈、单调双端队列进行缓存的结合，栈中判断需要索引还是只需要值

        - 快速选择（切分）：O(n)找到数组中第K大的数

        - 排序，归并和快排（注意快排要引入随机性）。归并可以用来统计逆序对，快速切分可以O(n)时间找到数组第K大的某值。

        - 二分，二分法常常跟着排序，换句话说，排序常常是二分的前置算法。二分数组的查询O(logn)

        - 前缀和，O(1)时间求前缀和，O(1)时间求区间和，但是有元素发生更改维护时间是O(n)

          ```python
          # 前缀和示例
          arr = [1,4,6,-3,5]
          pre = [0]
          p = 0
          for n in arr:
            p += n
            pre.append(p)
          
            
          pre[4]  # 前4个数的前缀和
          pre[1]  # 前1个数的前缀和
          ```

        - 树状数组，求前缀和O(logn)，求任意区间和也是O(logn)，修改任何一个元素维护的时间也是O(logn)。

          ```python
          arr = [1,4,6,-3,5]
          n = len(arr)
          BITree = [0] * (n + 1)
          def update(i, k=1):
            while i <= n:
              BITree[i] += k
              i += i & -i
          
          def getSum(i):
            s = 0
            while i:
              s += BITree[i]
              i -= i & -i
            return s
          ```

        - 一些二分操作，旋转数组（比较mid与r），局部极值数据（比较mid与mid+1），只有一个元素是一次其他都是两次的排序数组(mid是奇数就会退一个)

        - 一些离散化操作，比如用rank离散化，同时保持了数组的顺序。

   2. 链表

      1. 不同于数组·必须要连续的内存空间，链表可以使用零散的内存空间
      2. 不支持随机访问，访问为O(n)
      3. 插入和删除O(1)，但是需要前置节点。
      4. 经常需要一个dummy节点，next指向head。经常需要保留pre，cur两个指针，这样当cur需要被删掉，或者cur之前需要插入时，就有了前置节点的指针。
      5. 比数组占用空间大。
      6. 合并K个链表（n为链表平均长度，归并O(nklogk)空间复杂度O(logk)，堆存储(Onklogk)，空间复杂度O(k)）
      7. 链表排序（直接模拟归并的向上回升，可以在O(nlogn)时间复杂度，O(1)的空间复杂度内完成）
      8. 链表翻转
      9. 链表环的检测，快慢双指针
      10. 链表从后数第K个节点，前后双指针

   3. 哈希表

      1. 物理存储是数组，根据key算出数组下标，那么就可以快速的在数组中找到需要的key和value。hashmap和hashset本质上是一样的，也有在数组中存储的是指针，再通过指针找到实际存储的值。
      2. 最简单的hash函数是余数法。目前常用的有murmurhash3。
      3. 拉链法-平衡二叉树法解决冲突。

   4. 栈

      1. 很多先入后出的结构里都需要用到栈。很多时候我们可以用数组来实现栈。
      2. 在顺序表上增加限制，事情就简单了。而简单，正是我们做软件开发应该努力追求的一个目标。
      3. dfs

   5. 队列

      1. bfs

   6. 双端队列

      1. 很多语言推荐使用双端队列作为队列的实现。

2. 二维

   1. 树
      1. 二叉树（递归、分支）
      2. 学会后序遍历，中序遍历，前序遍历的精髓，了解其变种问题。
         1. 后续遍历相当于树的归并，总是先访问完树的左子树和右子树之后，在访问根节点，利用后序遍历，我们可以解决很多归并与递推问题，比如是否是平衡二叉树、最大路径和、直径、在二叉树中分配硬币、分裂二叉树的乘积最大值
         2. 中序遍历和二叉搜索树搭配很多，二叉搜索树转链表、循环双向链表、找到错的位置、由中序遍历和前序遍历还原一颗树。
      3. 二叉树的前缀和
      4. AVL，红黑树
      5. 很多递归问题最终都可以转化为树的搜索问题，画出状态树。
   2. 图
      1. 邻接矩阵邻接表表示，边的出度点在前，入度点在后。也就是出度表。
      2. 逆临界矩阵相反，表示的是顶点i的入度
      3. 入度表和出度表，我们可以用入度表和出度表来表示每一个顶点的入度和出度。出度表相当于邻接矩阵邻接表，压缩成一个数值表示边的数目。
      4. 拓扑排序可以通过bfs+贪心完成。将没有入度的点加入队列中，将它指向的顶点的入度减一，如果该顶点的入度为0，也将它加入队列中。
      5. 最小生成树算法。Prim's Algorithm，旅行商问题的2倍近似解法（旅行商问题是阶乘级别复杂度，不可行）。贪心算法。详见我的这篇[博客](https://hrz123.github.io/2020/08/21/Prim-s最小生成树算法/)。
         1. 所有点的键值为INF
         2. 原点的键值为0
         3. 开始时mstSet为空，另一个集合包含所有顶点。
         4. 从另一个集合中选取键值最小的加入mstSet，更新这个顶点的相邻顶点的键值为当前键值和其相连边的权重的最小值。
         5. 直到mstSet包含所有的顶点。
      6. 如何判断有向图有环。（dfs+标记）
         1. 定义一个全局的flags数组，大小为全部的节点数量，初始化为0，遍历所有的节点。数组中1表示正在被本轮递归访问，-1表示已经被之前的某轮递归访问过，0表示还没有被访问过。
         2. 在遍历一个节点时，如果它已经被标记上-1了，那么就返回True，因为这个节点已经被访问过了
         3. 如果它已经被标上1，那么返回False，说明我们在这一次遍历中再次访问到了这个节点。
         4. 将本节点标记为1，然后遍历邻接矩阵或者邻接表中的下一个节点，递归的调用。如果有一个返回False，就返回False。
         5. 如果都没有False返回，说明这个节点的相连节点都没有环的出现，将flags标记为-1，代表已经访问过。
      7. 如何判断无向图有环。（并查集）
         1. 遍历所有的边
         2. 如果对于边的两个顶点，目前不属于一个集合，union
         3. 如果对于边的两个顶点，目前已经属于一个集合，那么说明有环
      8. 拓扑排序
         1. 贪心+bfs/dfs
         2. 对于没有入度的，加入queue，或者stack
         3. 从queue/stack中拿出一个顶点，加入结果数组，将其相邻顶点的入度减1，如果现在该顶点的入度为0，那么将其加入queue或者stack
         4. 直到queue/stack为空。如果结果数组的长度等于顶点的数量，说明图中没有环。否则，说明有向图中有环。
         5. 结果数组就是给定图的一个拓扑排序。
      9. Dijkstra最短路径算法
      10. 图的遍历：bfs dfs （注意加visited）
      11. A*启发式搜索：在求最短路径，最小距离等问题时，我们往往使用bfs。而其实，对于一些更为靠近终点的候选者，是更有可能最快到达终点的。
   3. 字典树
   4. 并查集
   5. LRU Cache
   6. 布隆过滤器：二进制向量+一系列哈希函数

3. 合并N个有序数组，链表，排序数组，排序链表

4. 排序

   1. 所有排序

5. 字符串算法

   1. 匹配：BF、RK、KMP、BM
   2. 回文：dp，中间向两边扩散、manacher

6. 位运算

   1. N皇后，快速判重
   2. 解决一个数字出现p次，其他所有数字出现k次问题。
   3. 格雷码的规律

7. 数学

   1. 一些概率问题
   2. 数论中的一些问题
   3. 找规律问题

   

