# 双蛋问题.py


# 临界楼层以下（包括）都是不碎的，以上都碎，找出这个临界楼层
# 100层，有可能第1层就碎，有可能100层都不碎，有N个蛋，最少扔多少M次，找出临界层
# 跟有几个鸡蛋有关
# 1个鸡蛋，M=100
# 无限个鸡蛋，二分法，需要扔， log2(100) = 6.64, 7
# 2个蛋 N=2
# 0   10  20  30      100
# A 10 20 30 ... 100
# B x1, x2, x3, x4, .., x9
# 最多仍19次
# 这个方法有的时候是10次，有的时候是19次，在10到19次之间不平均
# 原因是A确定的间隔是等间隔的，等间隔就造成B这个鸡蛋去试的时候
# 每一次扔的次数最多都是一样的
# 但是临界楼层靠后的话，A扔的次数就多了
# 所以我们就思考，能不能让间隔变得不等
# A每多扔一次，B的这个间隔就锁小一点
# 让总次数平均一下，也许这种情况会更好

# 换一种方法
# 1   N   N-1    N-2     1    100
# (N+1)*N/2 >= 100, N>=13.65, N=14
# A  14  27   39  50  60  69  77  84  90 95  99  100   12次
# B
# 如果A到14层碎了， B需要检查1..13， 一共1 + 13 = 14次
# 如果A到27层碎了， B需要检查15..26， 一共2 + 12 = 14次
# 如果A到100层碎了，或者还没碎， B不需要检查， 一共12次
# 最差14次


# 精髓，递归思想
# 楼有T层，有N个蛋，最不利的情况下 至少要扔多少次，才能一定找到这个临界楼层 次数为M(T, N) ？
# 蛋的数目     1    2    3    4
# 楼层数  1    1    1    1    1
#        2    2
#        3    3
#
#
#
#

# 第一个鸡蛋扔在第k层
#  1          k                T
# 两种结果
# 碎和不碎
# 碎，临界楼层一定在前面（包括） M(k, N-1)
# 如果不碎，临界楼层一定在后面   M(T-k, N)
# 因为我们要找最不利，所以这两种情况要去一个最大值
# max(M(k, N-1), M(T-k, N)) + 1

# 递推公式， f_k(t, n) = max(f(k, n-1), f(t-k, n)) + 1 k 1..T
# 而k有很多种可能，每扔一次都可做一次运算
# f(t, n) = min(max(f(k, n-1), f(t-k, n))) + 1 k 1..T

# 原始问题，有m层楼，有n个鸡蛋，抛下鸡蛋，鸡蛋有可能在第1层碎，也有可能在第m层碎，
# 有一个楼层叫临界楼层，这个楼层不会碎，上一层就会碎
# 最少多少次抛鸡蛋，才能保证找到这个临界楼层
# 定义子问题
# i层楼有j个鸡蛋，最少用多次可以找到临界楼层 次数为f(i, j)
# 定义状态数组
# f(i, j) i 0..m j 1..n
# 递推方程
# 选第k层，碎了，之后为前k-1层用j-1个的最大次数，不碎，之后为i-k层用j个的最大次数
# 因为这里是必能找到，选择两个中最大值，加上这一次
# 遍历所有的k，取肯定能找到的次数的最小值，k的取值范围是从1到i
# f(i, j) = min(max(f(k-1, j-1), f(i-k, j))) + 1 k 1..i
# 初始化
# 注意到可能推到0层的情况
# 比如1到100层，第一次在1层扔，这时如果碎了，就不再需要扔鸡蛋了，
# 所以f(100, j)在第一层扔 = f(99, j) + 1
# 所以可以设0层不管有多少鸡蛋所需的次数为0，因为取max会忽略掉这个0，次数都是大于等于0的
# 0层的时候不需要扔也能判断了，f(0, j) = 0
# f(1, j) = max(f(0, j-1), f(0, j)) + 1 = 1,  k只能等于1
# 已经自动初始化
# f(i, 1) = i  只有一个鸡蛋时只能一层一层试
# i = 0的时候一直为0
# 只需要从i等于1遍历到i=m
# 返回值 f(m, n)
# 优化空间复杂度
# 可以只使用楼层数大小的数组
class Solution:
    def eggsProblem(self, levels: int, eggs: int):
        f = list(range(levels + 1))
        _f = [0] * (levels + 1)
        for _ in range(eggs - 1):
            for i in range(1, levels + 1):
                _f[i] = 1 + min(max(f[k - 1], _f[i - k])
                                for k in range(1, i + 1))
            f, _f = _f, f
        return f[levels]


def main():
    sol = Solution()

    res = sol.eggsProblem(100, 2)
    print(res)

    res = sol.eggsProblem(100, 10)
    print(res)


if __name__ == '__main__':
    main()
